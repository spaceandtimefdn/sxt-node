//! Autogenerated weights for `pallet_indexing`
//!
//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 42.0.0
//! DATE: 2025-01-14, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
//! WORST CASE MAP SIZE: `1000000`
//! HOSTNAME: `pop-os`, CPU: `AMD Ryzen 7 5700U with Radeon Graphics`
//! WASM-EXECUTION: `Compiled`, CHAIN: `None`, DB CACHE: 1024

// Executed Command:
// target/release/sxt-node
// benchmark
// pallet
// --pallet
// pallet_indexing
// --extrinsic
// *
// --steps=50
// --repeat=20
// --wasm-execution=compiled
// --output
// weights.rs

#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused_parens)]
#![allow(unused_imports)]
#![allow(missing_docs)]

use frame_support::{traits::Get, weights::Weight};
use core::marker::PhantomData;
use crate::{pallet, Config};

/// Weight functions for `pallet_indexing`.
pub trait WeightInfo {
    fn submit_data() -> Weight;
    /// Storage: `Permissions::Permissions` (r:1 w:0)
    /// Proof: `Permissions::Permissions` (`max_values`: None, `max_size`: Some(2193), added: 4668, mode: `MaxEncodedLen`)
    /// Storage: `Tables::Schemas` (r:1 w:0)
    /// Proof: `Tables::Schemas` (`max_values`: None, `max_size`: Some(8358), added: 10833, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::FinalData` (r:1 w:0)
    /// Proof: `Indexing::FinalData` (`max_values`: None, `max_size`: Some(2336), added: 4811, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::Submissions` (r:1 w:1)
    /// Proof: `Indexing::Submissions` (`max_values`: None, `max_size`: Some(1126), added: 3601, mode: `MaxEncodedLen`)
    fn submit_data_quorum_not_reached() -> Weight;
    /// Storage: `Permissions::Permissions` (r:1 w:0)
    /// Proof: `Permissions::Permissions` (`max_values`: None, `max_size`: Some(2193), added: 4668, mode: `MaxEncodedLen`)
    /// Storage: `Tables::Schemas` (r:1 w:0)
    /// Proof: `Tables::Schemas` (`max_values`: None, `max_size`: Some(8358), added: 10833, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::FinalData` (r:1 w:1)
    /// Proof: `Indexing::FinalData` (`max_values`: None, `max_size`: Some(2336), added: 4811, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::Submissions` (r:2 w:1)
    /// Proof: `Indexing::Submissions` (`max_values`: None, `max_size`: Some(1126), added: 3601, mode: `MaxEncodedLen`)
    /// Storage: `Commitments::CommitmentStorageMap` (r:2 w:1)
    /// Proof: `Commitments::CommitmentStorageMap` (`max_values`: None, `max_size`: Some(45497), added: 47972, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::BlockNumbers` (r:0 w:1)
    /// Proof: `Indexing::BlockNumbers` (`max_values`: None, `max_size`: Some(156), added: 2631, mode: `MaxEncodedLen`)
    fn submit_data_quorum_reached() -> Weight;
    /// Storage: UNKNOWN KEY `0x5f0eaa9161a01e3d007e08083fa1748247aabc8065823acc682503190fa1fbd7` (r:2 w:1)
    /// Proof: UNKNOWN KEY `0x5f0eaa9161a01e3d007e08083fa1748247aabc8065823acc682503190fa1fbd7` (r:2 w:1)
    /// Storage: `Indexing::SubmissionsV1` (r:0 w:64)
    /// Proof: `Indexing::SubmissionsV1` (`max_values`: None, `max_size`: Some(150), added: 2625, mode: `MaxEncodedLen`)
    fn migration_v0_v1_step() -> Weight;
    /// Storage: `Indexing::SubmissionsV1` (r:65 w:0)
    /// Proof: `Indexing::SubmissionsV1` (`max_values`: None, `max_size`: Some(150), added: 2625, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::CounterForBatchQueue` (r:1 w:1)
    /// Proof: `Indexing::CounterForBatchQueue` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::BatchQueue` (r:1 w:1)
    /// Proof: `Indexing::BatchQueue` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
    fn migration_v1_v2_step() -> Weight;
}

pub struct SubstrateWeight<T>(PhantomData<T>);
impl<T: frame_system::Config> WeightInfo for SubstrateWeight<T> {

    /// When submitting data we don't know if we'll reach quorum until after we execute the
    /// transaction. Because of this, we manually implement this weight which assumes that in
    /// 4 submissions we will have 3 with no quorum and 1 with a quorum.
    #[allow(clippy::identity_op)]
    fn submit_data() -> Weight {
        let submit_no_quorum = <SubstrateWeight<T> as WeightInfo>::submit_data_quorum_not_reached();
        let submit_w_quorum = <SubstrateWeight<T> as WeightInfo>::submit_data_quorum_reached();

        // Assume in 4 submissions, one will have a quorum event
        let submit_avg_time = ((3 * submit_no_quorum.ref_time()) + (1 * submit_w_quorum.ref_time()) / 4);
        let submit_avg_proof = ((3 * submit_no_quorum.proof_size()) + (1 * submit_w_quorum.proof_size()) / 4);

        Weight::from_parts(submit_avg_time, submit_avg_proof)
    }

    /// Storage: `Permissions::Permissions` (r:1 w:0)
    /// Proof: `Permissions::Permissions` (`max_values`: None, `max_size`: Some(2193), added: 4668, mode: `MaxEncodedLen`)
    /// Storage: `Tables::Schemas` (r:1 w:0)
    /// Proof: `Tables::Schemas` (`max_values`: None, `max_size`: Some(8358), added: 10833, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::FinalData` (r:1 w:0)
    /// Proof: `Indexing::FinalData` (`max_values`: None, `max_size`: Some(2336), added: 4811, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::Submissions` (r:1 w:1)
    /// Proof: `Indexing::Submissions` (`max_values`: None, `max_size`: Some(1126), added: 3601, mode: `MaxEncodedLen`)
    fn submit_data_quorum_not_reached() -> Weight {
        // Proof Size summary in bytes:
        //  Measured:  `851`
        //  Estimated: `11823`
        // Minimum execution time: 64_872_000 picoseconds.
        Weight::from_parts(65_403_000, 0)
                .saturating_add(Weight::from_parts(0, 11823))
                .saturating_add(T::DbWeight::get().reads(4))
                .saturating_add(T::DbWeight::get().writes(1))
    }
    /// Storage: `Permissions::Permissions` (r:1 w:0)
    /// Proof: `Permissions::Permissions` (`max_values`: None, `max_size`: Some(2193), added: 4668, mode: `MaxEncodedLen`)
    /// Storage: `Tables::Schemas` (r:1 w:0)
    /// Proof: `Tables::Schemas` (`max_values`: None, `max_size`: Some(8358), added: 10833, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::FinalData` (r:1 w:1)
    /// Proof: `Indexing::FinalData` (`max_values`: None, `max_size`: Some(2336), added: 4811, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::Submissions` (r:2 w:1)
    /// Proof: `Indexing::Submissions` (`max_values`: None, `max_size`: Some(1126), added: 3601, mode: `MaxEncodedLen`)
    /// Storage: `Commitments::CommitmentStorageMap` (r:2 w:1)
    /// Proof: `Commitments::CommitmentStorageMap` (`max_values`: None, `max_size`: Some(45497), added: 47972, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::BlockNumbers` (r:0 w:1)
    /// Proof: `Indexing::BlockNumbers` (`max_values`: None, `max_size`: Some(156), added: 2631, mode: `MaxEncodedLen`)
    fn submit_data_quorum_reached() -> Weight {
        // Proof Size summary in bytes:
        //  Measured:  `8014`
        //  Estimated: `96934`
        // Minimum execution time: 65_486_261_000 picoseconds.
        Weight::from_parts(65_686_228_000, 0)
                .saturating_add(Weight::from_parts(0, 96934))
                .saturating_add(T::DbWeight::get().reads(7))
                .saturating_add(T::DbWeight::get().writes(4))
    }
    /// Storage: UNKNOWN KEY `0x5f0eaa9161a01e3d007e08083fa1748247aabc8065823acc682503190fa1fbd7` (r:2 w:1)
    /// Proof: UNKNOWN KEY `0x5f0eaa9161a01e3d007e08083fa1748247aabc8065823acc682503190fa1fbd7` (r:2 w:1)
    /// Storage: `Indexing::SubmissionsV1` (r:0 w:64)
    /// Proof: `Indexing::SubmissionsV1` (`max_values`: None, `max_size`: Some(150), added: 2625, mode: `MaxEncodedLen`)
    fn migration_v0_v1_step() -> Weight {
        // Proof Size summary in bytes:
        //  Measured:  `2256`
        //  Estimated: `8196`
        // Minimum execution time: 303_120_000 picoseconds.
        Weight::from_parts(311_376_000, 0)
            .saturating_add(Weight::from_parts(0, 8196))
            .saturating_add(T::DbWeight::get().reads(2))
            .saturating_add(T::DbWeight::get().writes(65))
    }
    /// Storage: `Indexing::SubmissionsV1` (r:65 w:0)
    /// Proof: `Indexing::SubmissionsV1` (`max_values`: None, `max_size`: Some(150), added: 2625, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::CounterForBatchQueue` (r:1 w:1)
    /// Proof: `Indexing::CounterForBatchQueue` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
    /// Storage: `Indexing::BatchQueue` (r:1 w:1)
    /// Proof: `Indexing::BatchQueue` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
    fn migration_v1_v2_step() -> Weight {
        // Proof Size summary in bytes:
        //  Measured:  `6277`
        //  Estimated: `171615`
        // Minimum execution time: 133_010_000 picoseconds.
        Weight::from_parts(135_916_000, 0)
            .saturating_add(Weight::from_parts(0, 171615))
            .saturating_add(T::DbWeight::get().reads(67))
            .saturating_add(T::DbWeight::get().writes(2))
    }
}
